{"meta":{"title":"Coding 博客","subtitle":null,"description":"个人博客","author":"Coding","url":"https://leeyongda.github.io/jym"},"pages":[{"title":"categories","date":"2018-06-06T06:35:46.000Z","updated":"2018-06-06T06:35:46.062Z","comments":true,"path":"categories/index.html","permalink":"https://leeyongda.github.io/jym/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-06-06T06:35:24.000Z","updated":"2018-06-06T06:35:24.535Z","comments":true,"path":"tags/index.html","permalink":"https://leeyongda.github.io/jym/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"react-websocket","slug":"React-WebSokcet","date":"2018-06-06T05:12:00.000Z","updated":"2018-06-06T05:24:29.283Z","comments":true,"path":"2018/06/06/React-WebSokcet/","link":"","permalink":"https://leeyongda.github.io/jym/2018/06/06/React-WebSokcet/","excerpt":"","text":"React - WebSocket基于React 实现 WebSocket 连接12","categories":[{"name":"前端","slug":"前端","permalink":"https://leeyongda.github.io/jym/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://leeyongda.github.io/jym/tags/前端/"}]},{"title":"golang-Channels","slug":"golang-Channels","date":"2018-02-12T06:48:28.000Z","updated":"2018-02-12T07:10:59.185Z","comments":true,"path":"2018/02/12/golang-Channels/","link":"","permalink":"https://leeyongda.github.io/jym/2018/02/12/golang-Channels/","excerpt":"","text":"Golang–Channels(通道)一. 通道创建以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存 channel。channel 容量 &gt; 0 即带有缓冲的通道 1234567 // 创建无缓冲的的通道ch := make(chan int)ch1 := make(chan int, 0)// 创建有缓冲的通道ch := make(chan int, 1)ch1 := make(chan int, 3) 二. 通道发送和接收123456// \b发送数据到通道ch := make(chan int)ch &lt;- 1// 从通道中接收数据&lt;- ch 三. 通道的箭头使用, 注意点。 chan &lt;- int 只发送int 的channel, 只能发送不能接收。 &lt;- chan int 表示一个只接收int 的int channel, 只能接收不能发送。 箭头 &lt;- 和关键字chan 的相对位置表明了channel 的方向。 这种限制将在编译期检测。","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://leeyongda.github.io/jym/tags/golang/"}]},{"title":"Scrapy-Socks5代理中间件","slug":"Scrapy-Socks5代理中间件","date":"2018-01-05T09:30:15.000Z","updated":"2018-01-05T10:07:32.267Z","comments":true,"path":"2018/01/05/Scrapy-Socks5代理中间件/","link":"","permalink":"https://leeyongda.github.io/jym/2018/01/05/Scrapy-Socks5代理中间件/","excerpt":"","text":"Scrapy-Socks5代理中间件Demo环境： Python(2.7+) + Scrapy(1.1.1) + Twisted(16.6.0)官网没直接提供Socks 代理中间件 。所以写一个代理中间件 。需要依赖库 txsocksx 。pip install txsocksx midddlewares.py123456789101112131415161718192021222324252627282930313233343536# -*- coding: utf-8 -*-# 需要依赖 txsocksx# pip install txsocksxfrom txsocksx.http import SOCKS5Agentfrom twisted.internet import reactorfrom scrapy.xlib.tx import TCP4ClientEndpointfrom scrapy.core.downloader.webclient import _parsefrom scrapy.core.downloader.handlers.http11 import HTTP11DownloadHandler, ScrapyAgentproxyHost = \"xxxx.com\"proxyPort = 9020proxyUser = \"1234\"proxyPass = \"pass\"class Socks5DownloadHandler(HTTP11DownloadHandler): def download_request(self, request, spider): \"\"\"Return a deferred for the HTTP download\"\"\" agent = ScrapySocks5Agent(contextFactory=self._contextFactory, pool=self._pool) return agent.download_request(request)class ScrapySocks5Agent(ScrapyAgent): def _get_agent(self, request, timeout): # bindAddress = request.meta.get('bindaddress') or self._bindAddress #proxy = request.meta.get('proxy') #if proxy: #_, _, proxyHost, proxyPort, proxyParams = _parse(proxy) #_, _, host, port, proxyParams = _parse(request.url) proxyEndpoint = TCP4ClientEndpoint(reactor, proxyHost, proxyPort, endpointArgs=dict(methods=&#123;'login': &#123;proxyUser, proxyPass&#125;&#125;)) agent = SOCKS5Agent(reactor, proxyEndpoint=proxyEndpoint) return agent # return self._Agent(reactor, contextFactory=self._contextFactory, # connectTimeout=timeout, bindAddress=bindAddress, pool=self._pool) settings.py12345DOWNLOAD_HANDLERS = &#123; \"http\": \"myspider.midddlewares.Socks5DownloadHandler\", \"https\": \"myspider.midddlewares.Socks5DownloadHandler\"&#125; End","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://leeyongda.github.io/jym/tags/python/"}]},{"title":"python 设计模式-适配器模式","slug":"python-设计模式-适配器模式","date":"2017-12-11T09:44:56.000Z","updated":"2017-12-11T09:46:37.542Z","comments":true,"path":"2017/12/11/python-设计模式-适配器模式/","link":"","permalink":"https://leeyongda.github.io/jym/2017/12/11/python-设计模式-适配器模式/","excerpt":"","text":"Python 设计模式–适配器模式Demo1234567891011121314151617181920212223242526272829303132333435363738394041import abcclass Target(metaclass=abc.ABCMeta): \"\"\" Define the domain-specific interface that Client uses. \"\"\" def __init__(self): self._adaptee = Adaptee() @abc.abstractmethod def request(self): passclass Adapter(Target): \"\"\" Adapt the interface of Adaptee to the Target interface. \"\"\" def request(self): self._adaptee.specific_request()class Adaptee: \"\"\" Define an existing interface that needs adapting. \"\"\" def specific_request(self): passdef main(): adapter = Adapter() adapter.request()if __name__ == \"__main__\": main()","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://leeyongda.github.io/jym/tags/python/"}]},{"title":"golang rsa 加密","slug":"golang-rsa-加密","date":"2017-12-11T06:51:05.000Z","updated":"2017-12-11T06:53:16.434Z","comments":true,"path":"2017/12/11/golang-rsa-加密/","link":"","permalink":"https://leeyongda.github.io/jym/2017/12/11/golang-rsa-加密/","excerpt":"12345678910111213141516171819202122package mainimport ( \"crypto/aes\" \"crypto/cipher\" \"encoding/base64\" \"crypto/sha1\" \"fmt\" \"bytes\" \"encoding/hex\" \"strings\")// js 加密算法// var encrypted = CryptoJS.AES.encrypt(sendData, key,&#123;iv:iv,mode:CryptoJS.mode.CBC,padding:CryptoJS.pad.Pkcs7&#125;);// 换成Golang 加密 实现一遍const appKey = \"00003\";const appKeySecret = \"754DHA8DHPN976DS\";const versionName = \"1.0\"","text":"12345678910111213141516171819202122package mainimport ( \"crypto/aes\" \"crypto/cipher\" \"encoding/base64\" \"crypto/sha1\" \"fmt\" \"bytes\" \"encoding/hex\" \"strings\")// js 加密算法// var encrypted = CryptoJS.AES.encrypt(sendData, key,&#123;iv:iv,mode:CryptoJS.mode.CBC,padding:CryptoJS.pad.Pkcs7&#125;);// 换成Golang 加密 实现一遍const appKey = \"00003\";const appKeySecret = \"754DHA8DHPN976DS\";const versionName = \"1.0\" 1234567891011121314151617181920212223242526272829303132333435363738394041424344func PKCS5Padding(ciphertext []byte, blockSize int) []byte &#123; padding := blockSize - len(ciphertext)%blockSize padtext := bytes.Repeat([]byte&#123;byte(padding)&#125;, padding) return append(ciphertext, padtext...)&#125;func AesEncrypt(origData, key []byte) ([]byte, error) &#123; block, err := aes.NewCipher(key) if err != nil &#123; return nil, err &#125; blockSize := block.BlockSize() origData = PKCS5Padding(origData, blockSize) iv := []byte(\"754DHA8DHPN976DS\") blockMode := cipher.NewCBCEncrypter(block, iv) crypted := make([]byte, len(origData)) blockMode.CryptBlocks(crypted, origData) return crypted, nil&#125;func testAes() (string, string) &#123; key := []byte(\"754DHA8DHPN976DS\") result, err := AesEncrypt([]byte(`&#123;\"Phone\":\"13234567890\"&#125;`), key) if err != nil &#123; panic(err) &#125; var jsonString = base64.StdEncoding.EncodeToString(result) var signStr = appKeySecret+\"appKey\"+appKey+\"jsonString\"+jsonString+\"userToken\"+\"\"+\"v\"+versionName+appKeySecret r := sha1.Sum([]byte(signStr)) signStr = strings.ToUpper(hex.EncodeToString(r[:])) return signStr, jsonString&#125;func main() &#123; signstr, jsonstr := testAes() fmt.Println(signstr, \"\\n\",jsonstr)&#125;","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://leeyongda.github.io/jym/tags/golang/"},{"name":"爬虫","slug":"爬虫","permalink":"https://leeyongda.github.io/jym/tags/爬虫/"}]},{"title":"golang sign 加密算法，仿某网站js sign加密算法","slug":"golang-sign-加密算法","date":"2017-12-10T04:52:54.000Z","updated":"2017-12-10T08:29:06.060Z","comments":true,"path":"2017/12/10/golang-sign-加密算法/","link":"","permalink":"https://leeyongda.github.io/jym/2017/12/10/golang-sign-加密算法/","excerpt":"demo123456789101112package mainimport ( \"math\" \"math/rand\" \"time\" \"fmt\" \"strconv\" \"crypto/md5\" \"encoding/hex\")","text":"demo123456789101112package mainimport ( \"math\" \"math/rand\" \"time\" \"fmt\" \"strconv\" \"crypto/md5\" \"encoding/hex\") 1234567891011121314151617181920212223242526272829303132333435363738394041424344func getRandomNonce() string&#123; var chars = \"abcdefghijklmnopqrstuvwxyz0123456789\" var max = len(chars) var nonce = \"\" r := rand.New(rand.NewSource(time.Now().UnixNano())) ch := []rune(chars) for i := 0; i &lt; 32; i++&#123; aa := math.Floor(r.Float64() * float64(max)) nonce += string(ch[int(aa)]) &#125; return nonce&#125;func createSign(nonce string, cellphone string) string &#123; timestamp := time.Now().Unix() fmt.Println(\"时间戳参数:\", timestamp) fmt.Println(\"nonce参数:\", nonce) var originSign1 = `device_id=12345&amp;nonce=` + nonce + \"&amp;phone=\" + cellphone + \"&amp;timestamp=\" + strconv.FormatInt(timestamp*1000, 10); //注意顺序 h := md5.New() h.Write([]byte(originSign1)) // 需要加密的字符串为例如 123456 cipherStr := h.Sum(nil) fmt.Printf(\"sign: %s\\n\", hex.EncodeToString(cipherStr)) // 输出加密结果 signstr := hex.EncodeToString(cipherStr) fmt.Println(\"加密参数:\", originSign1) return signstr&#125;func main()&#123; // 手机号sign 加密 phone := \"1323456780\" nonce := getRandomNonce() fmt.Println(nonce) createSign(nonce, phone)&#125; 以下是代码片段 随机生成 有范围之间的随机\b整数12345678910111213// \b代码片段 随机生成 有范围之间的随机\b整数func RandInt64(min, max int64) int64 &#123; rand.Seed(time.Now().UnixNano()) fmt.Println(min + rand.Int63n(max-min+1)) return min + rand.Int63n(max-min+1)&#125;func main()&#123; // 例如 随机生成 1000 - 9999 之间的4位随机整数 RandInt64(1000, 9999) &#125;","categories":[],"tags":[{"name":"golang","slug":"golang","permalink":"https://leeyongda.github.io/jym/tags/golang/"},{"name":"爬虫","slug":"爬虫","permalink":"https://leeyongda.github.io/jym/tags/爬虫/"}]},{"title":"第一篇爬虫","slug":"第一篇爬虫","date":"2017-12-09T15:11:52.000Z","updated":"2017-12-10T05:41:38.264Z","comments":true,"path":"2017/12/09/第一篇爬虫/","link":"","permalink":"https://leeyongda.github.io/jym/2017/12/09/第一篇爬虫/","excerpt":"","text":"爬虫入门 简单的hello worddemo1234import requestsres = requests.get(\"https://wwww.baidu.com\")print res, res.status_codeprint res.content","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://leeyongda.github.io/jym/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://leeyongda.github.io/jym/tags/爬虫/"}]}]}